<!--
@license MIT License. Copyright (c) 2015 Hongchan Choi. All rights reserved.
-->
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../paper-styles/paper-styles.html">
<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html">

<script src="spiralglobal_waveform.js"></script>
<script src="timeruler.js"></script>
<script src="ampruler.js"></script>
<script src="waveform.js"></script>

<!--
Draws the time-domain representation of AudioBuffer which can be navigated or
zoomed by dragging the waveform with the mouse horizontally or vertically.
Zooming in and out the amplitude can be done by dragging the amplitude ruler
vertically.

Example:

    <spiral-waveform></spiral-waveform>

@demo
-->
<dom-module id="spiral-waveform">

  <style>
    :host {
      display: block;
      box-sizing: border-box;
      overflow: hidden;
      position: relative;
    }

    canvas {
      display: block;
    }

    #eOverlay {
      display: none;
      position: absolute;
      bottom: 10px;
      right: 20px;
      width: 300px;
      height: 48px;
      background-color: #000;
      color: #FFF;
    }

    #eTimeRuler {
      background-color: #B0BEC5;
      image-rendering: pixelated;
    }

    #eWaveformContainer {
      width: 100%;
      overflow-y: scroll;
      overflow-x: hidden;
      background-color: #90A4AE;
    }
  </style>

  <template>
    <div id="eOverlay"></div>
    <canvas id="eTimeRuler" on-track="_onTrackWaveform"></canvas>
    <div id="eWaveformContainer">
      <canvas id="eWaveform" on-track="_onTrackWaveform"></canvas>
    </div>
  </template>

</dom-module>

<script>

  Polymer({

    is: 'spiral-waveform',

    properties: {

      _width: {
        type: Number,
        value: 480,
      },

      _height: {
        type: Number,
        value: 256 + 32 // time ruler's height
      },

      _heightTimeRuler: {
        type: Number,
        value: 32
      },

      _widthAmpRuler: {
        type: Number,
        value: 43
      },

      _minHeightChannel: {
        type: Number,
        value: 256
      },

      _heightChannel: {
        type: Number,
        value: 256
      },

      _heightPadding: {
        type: Number,
        value: 3
      },

      _viewStart: {
        type: Number,
        value: 0
      },

      _viewEnd: {
        type: Number,
        value: 1
      },

      _maxDisplayGain: {
        type: Number,
        value: 1
      },

      _subsampleZoom: {
        type: Boolean,
        value: false
      },

      _overlayPos: {
        type: Object,
        value: {
          x: 0,
          y: 0
        }
      },

      _ctxTimeRuler: Object,
      _ctxWaveform: Object,
      _audioBuffer: Object,
      _controller: Object,

      _timeRuler: Object,
      _ampRulers: Array,
      _waveformDrawers: Array,

      _componentId: {
        type: String,
        value: 'spiral-waveform'
      },

      _uiMode: {
        type: String,
        value: 'IDLE'
      },

      isInitialized: {
        type: Boolean,
        value: false
      }

    },

    behaviors: [
      Polymer.IronResizableBehavior
    ],

    listeners: {
      'iron-resize': '_onResize'
    },


    /** Helpers **/

    // Spiral-element initializer.
    _initialize: function () {
      // For the time ruler rendering.
      this._ctxTimeRuler = this.$.eTimeRuler.getContext('2d');

      // For the amp ruler and the waveform.
      this._ctxWaveform = this.$.eWaveform.getContext('2d');

      // TODO: design behavior of this._heightChannel.
      this._heightChannel = this._minHeightChannel;

      // TODO: Attach hovering action to the waveform canvas.
      // this.$.eWaveform.addEventListener('mousemove',
      //   this._displayOverlay.bind(this), false);

      this._isInitialized = true;

      // The forced initial resizing.
      this.async(this._onResize, 1);
    },

    // Create submodules: TimeRuler, AmpRuler, Waveform
    _createModules: function () {
      if (!this._isInitialized || !this._audioBuffer)
        return;

      // Initialize view port with the default time range.
      this._viewStart = 0;
      this._viewEnd = this._audioBuffer.duration;

      // Create TimeRuler.
      this._timeRuler = SpiralWaveform.createTimeRuler(this._ctxTimeRuler,
        this._widthAmpRuler, 0, this._width, this._heightTimeRuler);

      // Create AmpRulers and WaveformDrawers for each channel.
      this._ampRulers = [];
      this._waveformDrawers = [];
      for (var i = 0; i < this._audioBuffer.numberOfChannels; i++) {
        var yOffset = i * (this._heightChannel + this._heightPadding);
        this._ampRulers[i] = SpiralWaveform.createAmpRuler(this._ctxWaveform,
          0, yOffset, this._widthAmmodupRuler, this._heightChannel);
        this._waveformDrawers[i] = SpiralWaveform.createWaveformDrawer(this._ctxWaveform,
          this._widthAmpRuler, yOffset, this._width, this._heightChannel);
        this._waveformDrawers[i].setChannelData(this._audioBuffer.getChannelData(i),
          this._audioBuffer.sampleRate);
      }

      // The overall size has changed. Forcible resize.
      this._onResize();
    },

    _onResize: function () {
      // If the element is not initialized, stop now.
      if (!this._isInitialized)
        return;

      // Update the size of the host element.
      this._width = this.clientWidth;
      this._height = this.clientHeight;

      // Adjust TimeRuler's (canvas) size.
      // TODO: Only for the initial drawing. This is done by .setSize() below
      // too.
      this.$.eTimeRuler.width = this._width;
      this.$.eTimeRuler.height = this._heightTimeRuler;

      // Adjust the size of waveform container div (view port) first.
      this.$.eWaveformContainer.style.width = this._width + 'px';
      this.$.eWaveformContainer.style.height = (this._height - this._heightTimeRuler) + 'px';

      if (this._audioBuffer) {
        // Change the size of TimeRuler canvas and object.
        this._timeRuler.setSize(this._width, this._heightTimeRuler);

        // Change the size of Waveform canvas and object.
        this._ctxWaveform.canvas.width = this._width;
        this._ctxWaveform.canvas.height = this._audioBuffer.numberOfChannels *
          (this._heightChannel + this._heightPadding);

        // Set the size of AmpRuler and WaveformDrawer.
        for (var i = 0; i < this._audioBuffer.numberOfChannels; i++) {
          this._ampRulers[i].setSize(this._widthAmpRuler, this._heightChannel);
          this._waveformDrawers[i].setSize(this._width, this._heightChannel);
        }
      }

      // Trigger redraw.
      this._updateView(this._viewStart, this._viewEnd, this._maxDisplayGain);
    },


    /** Render-related **/

    _displayOverlay: function (event) {
      // if (!this._isInitialized)
      //   return;

      // this._hoverPos.x = event.clientX;
      // this._hoverPos.y = event.clientY;

      // var now = this._timeRuler.getNowFromCurrentX(this._hoverPos.x);
      // this.$.eOverlay.textContent = 'NOW: ' + now.toFixed(4) + '\n';
      // this.$.eOverlay.textContent += 'FRAME: ' + ~~(now * 44100);
    },

    // Update time range and maximum amp for the view.
    _updateView: function (start, end, maxDisplayGain) {
      if (!this._audioBuffer)
        return;

      this._viewStart = (start || this._viewStart);
      this._viewEnd = (end || this._viewEnd);

      // If absPeak is not given and the buffer is available, calculate the peak
      // value.
      if (maxDisplayGain === undefined)
        this._maxDisplayGain = this._findAbsoluteMaxFromChannels() * 1.4;
      else
        this._maxDisplayGain = maxDisplayGain;

      // Update the timeRuler to get grid information.
      this._timeRuler.update(this._viewStart, this._viewEnd);

      for (var i = 0; i < this._audioBuffer.numberOfChannels; i++) {
        this._ampRulers[i].update(this._maxDisplayGain);
        this._waveformDrawers[i].updateGridInfo(
          this._timeRuler.getCurrentGrids(),
          this._ampRulers[i].getCurrentGrids()
        );
      }

      this._render();
    },

    _render: function () {
      for (var i = 0; i < this._audioBuffer.numberOfChannels; i++) {
        this._waveformDrawers[i].draw(this._viewStart, this._viewEnd, this._maxDisplayGain);
        this._ampRulers[i].draw();
      }

      this._timeRuler.draw();

      // Cleaning up no man's land. (left-upper corder)
      // color: '#CFD8DC',
      // colorShadow: '#607D8B',
      this._ctxTimeRuler.fillStyle = '#90A4AE';
      this._ctxTimeRuler.fillRect(0, 0, this._widthAmpRuler, this._heightTimeRuler);
    },


    /** UI helpers */

    // Fine the absolute maximum from all the channels.
    _findAbsoluteMaxFromChannels: function () {
      if (!this._audioBuffer)
        return 0;

      var numChannels = this._audioBuffer.numberOfChannels;
      var absMax = 0.0;
      for (var i = 0; i < numChannels; i++) {
        var data = this._audioBuffer.getChannelData(i);
        for (var j = 0; j < data.length; j++) {
          var absValue = Math.abs(data[j]);
          if (absMax < absValue)
            absMax = absValue;
        }
      }

      return absMax;
    },

    _zoomX: function (deltaY, zoomCenter) {
      // TODO: Arbitrary.
      var kUserDragFactor = 2.66;

      // Anchor zooming algorithm. The starting point of dragging becomes the
      // anchor of user interaction.
      var delta = this._timeRuler.getSecondsFromDeltaX(deltaY, this._viewStart, this._viewEnd) * kUserDragFactor;
      var anchor = this._viewStart + this._timeRuler.getSecondsFromDeltaX(zoomCenter - this._widthAmpRuler, this._viewStart, this._viewEnd);
      var r1 = (anchor - this._viewStart) / (this._viewEnd - this._viewStart);
      var r2 = (this._viewEnd - anchor) / (this._viewEnd - this._viewStart);
      var newStart = Math.max(this._viewStart + delta * r1, 0);
      var newEnd = Math.min(this._viewEnd - delta * r2, this._audioBuffer.duration);

      // Zoom above the maximum zoom range: 0.003 seconds. (3ms ~ 128 samples)
      if (newEnd - newStart > 0.003) {
        this._updateView(newStart, newEnd, this._maxDisplayGain);

        // And notify the controller UI touched.
        this._notify('viewport-change', {
          start: newStart,
          end: newEnd
        });
      }
    },

    _zoomY: function (deltaY) {
      // TODO: Arbitrary.
      var kUserDragFactor = 0.0075;
      var kMinAmp = 0.001; // -60dB

      // Adjust maximum amplitude to be displayed.
      var ampMax = Math.max(kMinAmp, this._maxDisplayGain + deltaY * kUserDragFactor);

      this._updateView(this._viewStart, this._viewEnd, ampMax);
    },

    _panX: function (deltaX) {
      // Calculate deltaX in seconds and new start/end.
      var deltaSec = this._timeRuler.getSecondsFromDeltaX(deltaX, this._viewStart, this._viewEnd);
      var start = this._viewStart - deltaSec;
      var end = this._viewEnd - deltaSec;

      // Pan only with the valid start/end position.
      if (0 <= start && end < this._audioBuffer.duration) {
        this._updateView(start, end, this._maxDisplayGain);

        // And notify the controller UI touched.
        this._notify('viewrange-change', {
          start: start,
          end: end
        });
      }
    },

    _onTrackWaveform: function (event) {
      if (!this._audioBuffer)
        return;

      var pos = event.detail;

      // Pure x, y coordinates should be contained inside the target element
      // without padding or margin.
      pos.x = event.detail.sourceEvent.offsetX;
      pos.y = event.detail.sourceEvent.offsetY;

      switch(pos.state) {
        case 'start':
          this._uiMode = (pos.x < this._widthAmpRuler) ? 'ZOOM_Y' : '';
          break;
        case 'track':
          if (this._uiMode !== 'ZOOM_Y')
            this._uiMode = (pos.ddx * pos.ddx < pos.ddy * pos.ddy) ? 'ZOOM_X' : 'PAN_X';

          switch (this._uiMode) {
            case 'ZOOM_X':
              this._zoomX(pos.ddy, pos.x);
              break;
            case 'ZOOM_Y':
              this._zoomY(pos.ddy);
              break;
            case 'PAN_X':
              this._panX(pos.ddx);
              break;
          }

          break;
        case 'end':
          this._uiMode = 'IDLE';
          break;
      }
    },


    /** communication */

    _notify: function (eventType, data) {
      if (this._controller)
        this._controller.postMessage(this._componentId, eventType, data);
    },

    // Polymer entry point.
    attached: function () {
      this._initialize();
    },

    /**
     * Sets the controller object for reporting the local state change.
     * @param {Object} controller A controller object. This typically is a
     *                            message router.
     */
    setController: function (controller) {
      this._controller = controller;
    },

    /**
     * Sets the audio buffer object to visualize.
     * @param {Object} audioBuffer AudioBuffer object to be rendered.
     */
    setAudioBuffer: function (audioBuffer) {
      if (!audioBuffer)
        return;

      this._audioBuffer = audioBuffer;

      // Update the maximum display gain on the new buffer.
      this._maxDisplayGain = this._findAbsoluteMaxFromChannels() * 1.4;

      // Create sub-modules and start the procedure.
      this._createModules();
    },

    /**
     * Sets start and end points of view range.
     * @param {Number} start Region start position in seconds.
     * @param {Number} end   Region end position in seconds.
     */
    setViewRange: function (start, end) {
      this._updateView(start, end, this._maxDisplayGain);
    }

  });

</script>
